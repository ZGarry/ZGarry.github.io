import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c as r,a as e,b as a,e as l,f as s}from"./app-80d0a436.js";const p="/assets/1720490439701-e4bab4a3.png",c="/assets/1720490508140-0ed778c0.png",d="/assets/1720490534254-de191067.png",g="/assets/1720490573327-9db0f21a.png",_={},h=s('<h1 id="_1-趋于混乱的代码" tabindex="-1"><a class="header-anchor" href="#_1-趋于混乱的代码" aria-hidden="true">#</a> #1 趋于混乱的代码</h1><blockquote><p>生命，以负熵为食。</p></blockquote><p>本文从熵的视角谈一谈对生活中一些事务的看法。</p><h2 id="代码趋于混乱" tabindex="-1"><a class="header-anchor" href="#代码趋于混乱" aria-hidden="true">#</a> 代码趋于混乱</h2><p>代码是天然的趋于混乱的。我想用软件界一些常见的思维和词汇，以熵的视角来谈谈这个问题。</p><h3 id="面向对象-用对象来解决混乱问题" tabindex="-1"><a class="header-anchor" href="#面向对象-用对象来解决混乱问题" aria-hidden="true">#</a> <strong>面向对象：用对象来解决混乱问题</strong></h3><p>面向对象对解决混乱度提出的解决方案是，将行为和数据赋予给对象。进而，有更加清晰的语意，并且代码也是天然分散的（不要小瞧这点，这很重要）；行为也会在更加适合解决它的那个对象中解决。但是，<strong>随意命名的对象</strong>，<strong>对象之间彼此不必要的耦合</strong>，导致了代码还是很多，混乱度还是很高。</p><ul><li>此阶段的负面设计：</li><li>XXXUtil满天飞，每次Util的出现，都是对象行为抽象不到位，API设计不合理的体现，过多的Util会让你的代码逐步向面向过程滑坡。</li><li>java过于复杂的I/O读取，我只想要一只香蕉，但是你一定要先new一个森林，然后在森林中初始化一只猴子，然后我才能获取猴子手里拿着的这支香蕉。</li><li>对象抽象不合理，考虑场景过少，无法替换，只能做@Deprecate</li></ul><p>有人提出了MVC，多层架构，逐步有人将这些架构抽离成为更加凝练的六边形架构，我们可以在架构层做一些事情，让我们代码天然的分层，每一层解决每一层的问题。</p><p>一个标准的mvc架构如下：<br><img src="'+p+'" alt="1720490439701" loading="lazy"></p><p>一个标准分层的架构如下：</p><figure><img src="'+c+'" alt="1720490508140" tabindex="0" loading="lazy"><figcaption>1720490508140</figcaption></figure><p>六边形架构：</p><figure><img src="'+d+'" alt="1720490534254" tabindex="0" loading="lazy"><figcaption>1720490534254</figcaption></figure><p>这些都是久经沉淀，逐步形成的架构，可以说是不同业务场景，不同业务量级下的最佳实践。</p><p>此阶段的负向设计：</p><ul><li>贫血模型，频繁且无意义的多层之间互转。</li><li>过度的粘连层，体现在对covert的过度使用，内部各类也频繁进行黏合。</li></ul><p>DDD则是意识到，在面向对象场景下，不论你架构设计如何合理，如果你对象本身设计不合理，必然无法解决熵的问题，反而会带来无穷无尽的新问题。</p><p>所以DDD强调，领域抽象，也不足为奇了。其实是将目光放在更好解决类关联的问题上。</p><h3 id="spring出世-ioc模式下的熵-logn-n-logn" tabindex="-1"><a class="header-anchor" href="#spring出世-ioc模式下的熵-logn-n-logn" aria-hidden="true">#</a> <strong>Spring出世：IOC模式下的熵[logn*n-&gt;logn]</strong></h3><p>这一阶段，Spring等优秀框架推广了两个重要思想：</p><ul><li>依赖注入</li><li>控制反转</li></ul><p>对于调用方，这简直不是熵减，而是彻底解决了各种厚重的粘合层；不同集体，不同代码开发者之间的问题，比接口更加彻底。例如各个中间层，最好就要能做到让外部自助使用，如果能彻底用依赖注入的模式改造，让服务可自助，效率提升会几何倍。</p><p>其实除了常见的spring开发使用了较多该思想之外，插件模式，也是该思想的熟练运用者。</p><p>如何维护若干的，彼此之间独立的插件：</p><figure><img src="'+g+'" alt="1720490573327" tabindex="0" loading="lazy"><figcaption>1720490573327</figcaption></figure><p>插件模式适用于流程固定，插件之间属于彼此平行的关系。</p><p>另一种模式是流程引擎。如下，对于不并行的问题，混乱度得以巨大的解决。（原本由各自管理，变成抽象为配置，由流程引擎管理）</p>',28),f={href:"https://liteflow.yomahub.com/",target:"_blank",rel:"noopener noreferrer"},u=e("h3",{id:"微服务-服务拆分直接从代码量级的角度降低复杂度",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#微服务-服务拆分直接从代码量级的角度降低复杂度","aria-hidden":"true"},"#"),a(),e("strong",null,"微服务：服务拆分直接从代码量级的角度降低复杂度")],-1),m=e("p",null,"微服务引入了很多问题。但也解决了很多问题，其中很重要的一点，现在，大家再也不用面对动辄四五十万行的代码了，如此巨大代码，开发时的冲突，对其他内容的干扰。进行服务拆分后，可以拆分成3~4w行的一个个小的服务。",-1),b=e("p",null,"这，就是巨大的复杂度降低。",-1);function x(k,D){const t=n("ExternalLinkIcon");return o(),r("div",null,[h,e("p",null,[e("a",f,[a("https://liteflow.yomahub.com/"),l(t)])]),u,m,b])}const I=i(_,[["render",x],["__file","1 趋于混乱的代码.html.vue"]]);export{I as default};
